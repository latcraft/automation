
import groovyx.net.http.*
import groovyx.net.http.Method
import static groovyx.net.http.ContentType.*
import static groovyx.net.http.Method.*
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.security.MessageDigest

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath "org.codehaus.groovy.modules.http-builder:http-builder:0.7.1"
  }
}

apply from: '../common-utils/github-data.gradle'

ext {

  eventbriteFile = file("${buildDir}/eventbrite.json")  
  sha1 = MessageDigest.getInstance("SHA1")

  templateEngine = new groovy.text.SimpleTemplateEngine()
  defaultTemplateFile = file('templates/event_description.html')

  eventbrite = { Method method, String path, Map jsonBody, Closure cl ->
    def http = new HTTPBuilder('https://www.eventbriteapi.com/')
    http.ignoreSSLIssues()
    http.request(method, JSON) {
      uri.path = "${path}"
      uri.query = [ token: latcraftEventbriteToken ]
      if (jsonBody) {
        logger.debug JsonOutput.prettyPrint(JsonOutput.toJson(jsonBody))
        body = jsonBody
      }
      response.success = { _, json ->
        if (cl) {
          cl(json)
        }
      }
      response.failure = { resp ->
        throw new GradleException("Error details: ${resp.statusLine.statusCode} : ${resp.statusLine.reasonPhrase} : ${resp?.entity?.content?.text}")
      }
    }
  }

  github = { Method method, String path, Map jsonBody, Closure cl ->
    def http = new HTTPBuilder('https://api.github.com')
    http.ignoreSSLIssues()
    http.request(method, JSON) {
      headers.'Content-Type' = 'application/json'
      headers.'Accept' = 'application/vnd.github.v3+json'
      headers.'User-Agent' = 'Groovy HTTPBuilder'
      uri.path = "${path}"
      uri.query = [ access_token: latcraftGitHubToken ]
      if (jsonBody) {
        logger.debug JsonOutput.prettyPrint(JsonOutput.toJson(jsonBody))
        body = jsonBody
      }
      response.success = { _, json ->
        if (cl) {
          cl(json)
        }
      }
      response.failure = { resp ->
        throw new GradleException("Error details: ${resp.statusLine.statusCode} : ${resp.statusLine.reasonPhrase} : ${resp?.entity?.content?.text}")
      }
    }
  }

  slack = {

  }

  getEventBriteEvents = { 
    new JsonSlurper().parse(eventbriteFile).events
  }

}

task getEventBriteData << {
  buildDir.mkdirs()
  eventbrite(GET, '/v3/users/me/owned_events', [:]) { data ->
    eventbriteFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(data))
  }
}

getEventBriteData.outputs.file eventbriteFile

task makeEventBriteDescription(dependsOn: getMasterData) << {
  buildDir.mkdirs()
  getEvents().each { event ->    
    String eventId = dateFormat.parse(event.date).format('yyyyMMdd')    
    File overridenTemplateFile = file("templates/event_description_${eventId}.html")
    def template = templateEngine.createTemplate(overridenTemplateFile.exists() ? overridenTemplateFile : defaultTemplateFile)
    def binding = [ event: event ]    
    file("${buildDir}/event_description_${eventId}.html").text = template.make(binding).toString()
  }  
}

task synchronizeEventBriteData(dependsOn: [getMasterData, getEventBriteData, makeEventBriteDescription]) << {
  getFutureEvents().each { event ->

    // Calculate unique event ID used to distinguish this event from others in various data sources.
    String eventId = dateFormat.parse(event.date).format('yyyyMMdd')        

    // Find EventBrite event ID if it is not yet set or missing.
    String eventbriteEventId = event.eventbriteEventId
    if (!eventbriteEventId) {
      getEventBriteEvents().each { eventbriteEvent ->        
        if (isoDateFormat.parse(eventbriteEvent.start.local).format('yyyyMMdd') == eventId) {
          eventbriteEventId = eventbriteEvent.id
        }
      }
    }

    // Calculate input parameters.
    String apiUrl = eventbriteEventId ? "/v3/events/${eventbriteEventId}/" : "/v3/events/"
    def startTime = isoDateFormat.parse(dateFormat.parse(event.date).format('yyyy-MM-dd') + 'T' + event.time + ':00')
    def endTime = isoDateFormat.parse(dateFormat.parse(event.date).format('yyyy-MM-dd') + 'T' + event.endTime + ':00')

    // Create or update event information.
    println "> Creating/updating \"LatCraft | ${event.theme}\" (${eventId}, ${eventbriteEventId})"
    eventbrite(POST, apiUrl, [
      event: [
        name: [
          html: "LatCraft | ${event.theme}".toString()
        ],
        currency: 'EUR',
        start: [
          utc: startTime.format("yyyy-MM-dd'T'HH:mm:ss'Z'", gmt),
          timezone: 'Europe/Riga'
        ],
        end: [
          utc: endTime.format("yyyy-MM-dd'T'HH:mm:ss'Z'", gmt),
          timezone: 'Europe/Riga'
        ],
        venue_id: latcraftEventbriteVenueId,
        organizer_id: latcraftEventbriteOrganizerId,
        logo_id: latcraftEventbriteLogoId,
        category_id: latcraftEventbriteCategoryId,
        subcategory_id: latcraftEventbriteSubcategoryId,
        format_id: latcraftEventbriteFormatId,
        capacity: latcraftEventbriteCapacity,
        show_remaining: true,
        description: [
          html: file("${buildDir}/event_description_${eventId}.html").text
        ]
      ]
    ]) { data ->
      if (!event.eventbriteEventId) {
        def events = getEvents()
        events.each { updatedEvent ->
          if (dateFormat.parse(updatedEvent.date).format('yyyyMMdd') == eventId) {
            updatedEvent.eventbriteEventId = data.id
            updatedEvent.tickets = data.url
            eventbriteEventId = data.id
          }
        }        
        eventFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(events))
      }     
    }

    // Retrieve existing ticket classes.
    apiUrl = "/v3/events/${eventbriteEventId}/ticket_classes/"
    String eventbriteTicketClassId = null
    eventbrite(GET, apiUrl, [:]) { data ->
      eventbriteTicketClassId = data.ticket_classes?.find{ true }?.id
    }

    // Create or update ticket class.
    apiUrl = eventbriteTicketClassId ? "/v3/events/${eventbriteEventId}/ticket_classes/${eventbriteTicketClassId}/" : "/v3/events/${eventbriteEventId}/ticket_classes/" 
    eventbrite(POST, apiUrl, [
      ticket_class: [
        name: 'Free ticket',
        free: true,
        minimum_quantity: 1,
        maximum_quantity: 1,
        quantity_total: latcraftEventbriteCapacity
      ]
    ]) { data ->
      logger.debug data.toString()
    }

    // Publish event.
    apiUrl = "/v3/events/${eventbriteEventId}/publish/"
    eventbrite(POST, apiUrl, [:]) { data ->
      logger.debug data.toString()
    }

  }  
}

task updateEventBriteDataInGitHub(dependsOn: getMasterData) << {
  String checksum = github(GET, '/repos/latcraft/website/contents/data/events.json', [:]) { data ->
    return data.sha
  }
  String content = eventFile.bytes.encodeBase64().toString() 
  github(PUT, '/repos/latcraft/website/contents/data/events.json', [
    message: "updating event data",
    committer: [
      name: "Latcraft Event Manager",
      email: "hello@latcraft.lv"
    ],                     
    content: content,
    sha: checksum
  ]) { data ->
    logger.debug data.toString()
  }
}

updateEventBriteDataInGitHub.mustRunAfter synchronizeEventBriteData

task clean(type: Delete) {
  delete buildDir
}

task build(dependsOn: [synchronizeEventBriteData, updateEventBriteDataInGitHub])
