
import com.google.zxing.BarcodeFormat
import com.google.zxing.client.j2se.MatrixToImageWriter
import com.google.zxing.common.BitMatrix
import com.google.zxing.qrcode.QRCodeWriter
import com.google.zxing.EncodeHintType

import org.apache.batik.transcoder.image.JPEGTranscoder
import org.apache.batik.transcoder.TranscoderInput
import org.apache.batik.transcoder.TranscoderOutput

import groovy.util.XmlSlurper
import groovy.xml.XmlUtil

import java.awt.image.BufferedImage
import java.awt.Graphics2D
import java.awt.Color

import static javax.imageio.ImageIO.*


buildscript {
  repositories { mavenCentral() }
  dependencies {
    classpath 'com.google.zxing:core:3.2.0'
    classpath 'com.google.zxing:javase:3.2.0'
    classpath('batik:batik-transcoder:1.6-1') {
      exclude module: 'fop'
    }
    classpath 'xerces:xercesImpl:2.11.0'
  }
}


task generateBadges << {
  buildDir.mkdirs()
  File svgTemplate = file('badge_template.svg')
  int fileIndex = 1
  forEachPerson { firstName, lastName, email, company, type ->
    logger.quiet "> Generating badge for ${lastName}, ${firstName}"
    String indexString = (fileIndex++).toString().padLeft(3, '0')
    String baseName = "${indexString}_${lastName}"
    File svgBadgeFile = file("${buildDir}/${baseName}_badge.svg")    
    File qrFile = renderQRCodeImage(getBadgeUrl(firstName, lastName, email, company), buildDir, baseName)
    svgBadgeFile.text = modifySVG(svgTemplate.text, firstName, lastName, email, company, type, qrFile)
    renderBadgeImage(svgBadgeFile, buildDir, baseName)
    qrFile.delete()
    svgBadgeFile.delete()
  }
}

generateBadges.logging.captureStandardOutput LogLevel.INFO
generateBadges.logging.captureStandardError LogLevel.INFO


task concatenateBadges(dependsOn: generateBadges) << {
  File pageDir = file("${buildDir}/pages")
  pageDir.mkdirs()
  int badgesPerPage = 16
  int badgeHeight = 410
  int badgeWidth = 1190
  int badgeMargin = 6
  int startX = 50
  int startY = 50
  buildDir.listFiles().findAll { it.name.endsWith('.jpg') }.collate(badgesPerPage).eachWithIndex { badgeGroup, groupIndex ->
    BufferedImage page = read(new File('a4.jpg'))
    Graphics2D pageGraphics = page.createGraphics()
    pageGraphics.setColor(Color.LIGHT_GRAY)
    println "> Generating page ${groupIndex}"
    badgeGroup.eachWithIndex { File badgeFile, imageIndex ->
      BufferedImage badgeImage = read(badgeFile)
      println "> Adding ${imageIndex}:${badgeFile.name} to page"
      int x = (imageIndex % 2) * (badgeWidth + badgeMargin * 2) + startX
      int y = ((int)(imageIndex / 2)) * (badgeHeight + badgeMargin * 2) + startY
      pageGraphics.drawImage(badgeImage, null, x, y)
      pageGraphics.drawLine(0, y, Integer.MAX_VALUE, y)
      pageGraphics.drawLine(0, y + badgeHeight, Integer.MAX_VALUE, y + badgeHeight)
      pageGraphics.drawLine(x, 0, x, Integer.MAX_VALUE)
      pageGraphics.drawLine(x + badgeWidth, 0, x + badgeWidth, Integer.MAX_VALUE)
    }
    write(page, "JPG", new File(pageDir, "page${groupIndex.toString().padLeft(3, '0')}.jpg"))  
  }
}

concatenateBadges.mustRunAfter generateBadges

task clean(type: Delete) {
  delete buildDir
}


def modifySVG(String svgText, String firstName, String lastName, String email, String company, String badgeType, File qrFile) {
  def svg = new XmlSlurper().parseText(svgText)
  def badgeFirstName = svg.depthFirst().find { it.@id == 'badge-first-name' }
  def badgeLastName = svg.depthFirst().find { it.@id == 'badge-last-name' }
  badgeFirstName.replaceBody(sanitizeName(firstName))
  badgeLastName.replaceBody(sanitizeName(lastName))
  svg.depthFirst().find { it.@id == 'badge-company' }.replaceBody(sanitizeCompany(company))
  // svg.depthFirst().find { it.@id == 'badge-type' }.replaceBody badgeType
  svg.depthFirst().find { it.@id == 'badge-qr' }.@'xlink:href' = "data:image/png;base64,${qrFile.bytes.encodeBase64().toString().toList().collate(76)*.join().join(' ')}".toString()
  // def color = badgeType.startsWith('S') ? '225500' : badgeType.startsWith('O') ? '800000' : '162D50'
  // svg.depthFirst().find { it.@id == 'badge-color' }.@style = "fill:#${color};fill-opacity:1;fill-rule:evenodd;stroke:none".toString()
  XmlUtil.serialize(svg)
}


String sanitizeName(String name) {
  name.
    trim().
    split('\\s+').collect { 
      it.
        trim().
        capitalize() 
    }.
    join(' ')
}


String sanitizeCompany(String company) {
  sanitizeName(
    company.
      replaceAll('n/a', '').
      replaceAll('LV', '').
      replaceAll('Intelligent Technologies', 'IT').
      replaceAll('VSIA', '').
      replaceAll('vsia', '').
      replaceAll('sia', '').
      replaceAll('SIA', '').
      replaceAll('LTD', '').
      replaceAll('AS', '').
      replaceAll('ltd', '').
      replaceAll('Ltd.', '').
      replaceAll('Trade & Finance Group', '').
      replaceAll('Self Employed', '').
      replaceAll('GmbH', '').
      replaceAll('No Company :\\(', '').
      replaceAll('-', '').
      replaceAll('Latvia', '').
      replaceAll('private', '').
      trim().
      capitalize()
  )
}


def renderBadgeImage(File svgFile, File baseDir, String baseName) {
  JPEGTranscoder t = new JPEGTranscoder()
  t.addTranscodingHint(JPEGTranscoder.KEY_QUALITY, new Float(1))
  String svgURI = svgFile.toURL().toString()
  t.transcode(new TranscoderInput(svgURI), new TranscoderOutput(new FileOutputStream("${baseDir}/${baseName}_badge.jpg")))
}


File renderQRCodeImage(String content, baseDir, baseName, width = 300, height = 300) {
  File targetFile = file("${baseDir}/${baseName}_qr.png")
  def hints = new EnumMap<EncodeHintType, Object>(EncodeHintType)
  hints.put(EncodeHintType.CHARACTER_SET, "UTF-8")
  hints.put(EncodeHintType.MARGIN, 0)
  BitMatrix bitMatrix = new QRCodeWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints)
  MatrixToImageWriter.writeToFile(bitMatrix, "png", targetFile)
  targetFile
}


def getBadgeUrl(firstName, lastName, email, company) {
  "mailto:${email}"
}


def forEachPerson(Closure cl) {
  def lines = file(project.hasProperty('dataFile') ? project.dataFile : 'data.csv').readLines().drop(1).collect { it.trim() }.findAll { it.contains(';') }
  lines.each { String line ->
    def fields = line.split(';')
    cl(fields[0], fields[1], fields[2], fields[3], fields[3])
  }
}




